<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é¢˜åº“ - å†»æ¢¨OJ</title>
    <link rel="stylesheet" href="/css/index.css">
    <link rel="stylesheet" href="/css/all_questions.css">
    <!-- Markdown Libraries -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/easymde/dist/easymde.min.css">
    <script src="https://cdn.jsdelivr.net/npm/easymde/dist/easymde.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js"></script>
    <style>
        .inline-comment-target {
            border-bottom: 1px dashed #999;
            cursor: pointer;
            position: relative;
        }
        .inline-comment-target:hover {
            border-bottom-color: #2cbb5d;
            background-color: rgba(44, 187, 93, 0.1);
        }
        
        /* Side Drawer */
        .comment-drawer {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100%;
            background: var(--card-bg);
            box-shadow: -2px 0 10px rgba(0,0,0,0.5);
            z-index: 1500;
            transition: right 0.3s ease;
            display: flex;
            flex-direction: column;
            border-left: 1px solid rgba(255,255,255,0.1);
        }
        .comment-drawer.visible {
            right: 0;
        }
        .comment-drawer-header {
            padding: 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .comment-drawer-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }
        .comment-drawer-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.3);
            z-index: 1400;
            display: none;
        }
        .comment-drawer-backdrop.visible {
            display: block;
        }
        
        .selected-text-quote {
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-left: 3px solid #2cbb5d;
            margin-bottom: 20px;
            font-style: italic;
            color: var(--text-secondary);
        }

        /* EasyMDE Dark Mode Customization */
        .EasyMDEContainer {
            background: transparent;
        }
        .editor-toolbar {
            background-color: rgba(255,255,255,0.05) !important;
            border-color: rgba(255,255,255,0.1) !important;
            display: flex;
            flex-wrap: wrap;
            padding: 8px !important;
        }
        .editor-toolbar button {
            color: var(--text-main) !important;
            width: 36px !important;
            height: 36px !important;
            border-radius: 4px !important;
            margin: 2px !important;
            font-size: 16px !important;
        }
        .editor-toolbar button:hover, .editor-toolbar button.active {
            background-color: rgba(255,255,255,0.1) !important;
            border: none !important;
        }
        .editor-toolbar i.separator {
            border-left: 1px solid rgba(255,255,255,0.1) !important;
            border-right: none !important;
            margin: 0 8px !important;
        }
        .CodeMirror {
            background-color: var(--card-bg) !important;
            color: var(--text-main) !important;
            border-color: rgba(255,255,255,0.1) !important;
            min-height: 400px;
        }
        .CodeMirror-cursor {
            border-color: var(--text-main) !important;
        }
        .editor-statusbar {
            color: var(--text-secondary) !important;
        }
        .editor-preview {
            background-color: var(--card-bg) !important;
        }
        .editor-preview-side {
            border-color: rgba(255,255,255,0.1) !important;
        }
        
        /* Custom Fullscreen Exit Button */
        #exit-fullscreen-btn {
            position: fixed;
            bottom: 40px;
            right: 40px;
            z-index: 2147483647; /* Max z-index */
            padding: 10px 20px;
            background: rgba(44, 187, 93, 0.9);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        #exit-fullscreen-btn:hover {
            background: #2cbb5d;
        }
    </style>
</head>
    <script>
        // XSSé˜²æŠ¤
        function escapeHtml(text) {
            const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
            return text ? text.replace(/[&<>"']/g, function(m) { return map[m]; }) : '';
        }

        function hideUserMenu() {
            const menu = document.getElementById('user-menu');
            const backdrop = document.getElementById('user-menu-backdrop');
            if (menu) menu.classList.remove('visible');
            if (backdrop) backdrop.classList.remove('visible');
            document.removeEventListener('click', onUserMenuDocumentClick);
        }

        function onUserMenuDocumentClick(event) {
            const profile = document.querySelector('.user-profile');
            const menu = document.getElementById('user-menu');
            if (!profile || !menu) {
                hideUserMenu();
                return;
            }
            if (!profile.contains(event.target) && !menu.contains(event.target)) {
                hideUserMenu();
            }
        }

        function toggleUserMenu(event) {
            event.stopPropagation();
            console.log('[all_questions toggleUserMenu] called');
            const menu = document.getElementById('user-menu');
            const backdrop = document.getElementById('user-menu-backdrop');
            if (!menu || !backdrop) {
                console.warn('[all_questions toggleUserMenu] menu or backdrop not found');
                return;
            }
            const isVisible = menu.classList.contains('visible');
            console.log('[all_questions toggleUserMenu] isVisible =', isVisible);
            if (isVisible) {
                hideUserMenu();
            } else {
                menu.classList.add('visible');
                backdrop.classList.add('visible');
                document.addEventListener('click', onUserMenuDocumentClick);
                console.log('[all_questions toggleUserMenu] menu opened');
            }
        }

        async function handleLogout(event) {
            event.stopPropagation();
            try {
                const response = await fetch('/api/logout', {
                    method: 'GET'
                });
                const data = await response.json();
                if (data.status === 0) {
                    window.location.reload();
                } else {
                    alert('ç™»å‡ºå¤±è´¥ï¼š' + (data.reason || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (e) {
                alert('ç™»å‡ºè¯·æ±‚å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
            }
        }

        function updateNavAuth(data) {
            const authContainer = document.getElementById('auth-container');
            if (data.status === 0 && data.username) {
                currentUser = data;
                authContainer.innerHTML = `
                    <div class="user-profile" onclick="toggleUserMenu(event)">
                        <div class="user-avatar">${data.username.charAt(0).toUpperCase()}</div>
                        <span>${escapeHtml(data.username)}</span>
                    </div>
                    <div class="user-menu-backdrop" id="user-menu-backdrop" onclick="hideUserMenu()"></div>
                    <div class="user-menu" id="user-menu">
                        <a href="/profile" class="user-menu-item">ä¸ªäººä¸­å¿ƒ</a>
                        <button type="button" class="user-menu-item" onclick="handleLogout(event)">é€€å‡ºç™»å½•</button>
                    </div>
                `;
            } else {
                authContainer.innerHTML = `<a href="/login" class="btn-text">ç™»å½• / æ³¨å†Œ</a>`;
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            console.log('[all_questions] DOMContentLoaded');
            
            // Check for view parameter
            const urlParams = new URLSearchParams(window.location.search);
            const viewParam = urlParams.get('view');
            if (viewParam === 'discussion') {
                switchView('view-discussion-feed');
                initDiscussion();
            }

            const authContainer = document.getElementById('auth-container');
            if (!authContainer) {
                console.error('[all_questions] #auth-container not found');
                return;
            }
            authContainer.innerHTML = '<span class="btn-text loading">åŠ è½½ä¸­...</span>';

            fetch('/api/user')
                .then(res => res.json())
                .then(data => {
                    console.log('[all_questions] /api/user response', data);
                    updateNavAuth(data);
                })
                .catch(err => {
                    console.error('[all_questions] /api/user error', err);
                    updateNavAuth({status: -1});
                });
        });

        // --- View Management ---
        function switchView(viewId) {
            // Hide all views
            ['view-question-list', 'view-discussion-feed', 'view-post-detail', 'view-editor'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = 'none';
            });
            
            // Show target view
            const target = document.getElementById(viewId);
            if (target) {
                target.style.display = 'block';
                // Update nav active state
                document.querySelectorAll('.navbar-links a').forEach(a => a.classList.remove('active'));
                if (viewId === 'view-question-list') {
                    document.querySelector('a[href="/all_questions"]').classList.add('active');
                } else {
                    document.getElementById('nav-discussion').classList.add('active');
                }
            }
        }

        // --- Discussion Module Logic ---
        let simplemde = null;
        let currentUser = null;
        let currentPostRenderedHTML = "";
        
        async function initDiscussion() {
            try {
                const response = await fetch('/api/discussions');
                const res = await response.json();
                if (res.status === 0) {
                    renderFeed(res.data || []);
                } else {
                    console.error('Failed to load discussions');
                }
            } catch (e) {
                console.error(e);
            }
        }

        function renderFeed(posts) {
            const container = document.getElementById('discussion-feed-list');
            if(!container) return;
            
            if (!posts) posts = [];

            if (posts.length === 0) {
                container.innerHTML = '<div style="text-align:center; padding:40px; color:var(--text-secondary);">æš‚æ— è®¨è®ºï¼Œå¿«æ¥å‘å¸ƒç¬¬ä¸€ç¯‡å§ï¼</div>';
                return;
            }
            
            container.innerHTML = posts.map(post => `
                <div class="discussion-card" onclick="openPost(${post.id})">
                    <div class="card-header">
                        <div class="user-info">
                            <span class="username">${escapeHtml(post.author)}</span>
                            <span class="date">Â· ${post.date}</span>
                        </div>
                        ${post.isOfficial ? '<span class="tag-official">å®˜æ–¹</span>' : ''}
                    </div>
                    <h3 class="card-title">${escapeHtml(post.title)}</h3>
                    <p class="card-summary">${escapeHtml(post.summary)}</p>
                    <div class="card-footer">
                        <div class="stats">
                            <span>ğŸ‘ ${post.likes}</span>
                            <span>ğŸ‘ ${post.views}</span>
                            <span>ğŸ’¬ ${post.comments}</span>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        let currentPostId = "";

        async function openPost(id) {
            switchView('view-post-detail');
            currentPostId = id;
            document.getElementById('post-detail-content').innerHTML = '<div class="loading">åŠ è½½ä¸­...</div>';
            
            try {
                const response = await fetch('/api/discussion/' + id);
                const res = await response.json();
                if (res.status === 0 && res.data) {
                    const post = res.data;
                    const renderedHTML = marked.parse(post.content || '');
                    currentPostRenderedHTML = renderedHTML;
                    document.getElementById('post-detail-content').innerHTML = `
                        <h1>${escapeHtml(post.title)}</h1>
                        <div class="post-meta">${escapeHtml(post.author)} Â· ${post.date} Â· ğŸ‘ ${post.views}</div>
                        <div class="markdown-body" id="post-markdown-content">
                            ${renderedHTML} 
                        </div>
                    `;
                    initInlineComments();
                    loadInlineComments();
                    loadArticleComments();
                } else {
                    document.getElementById('post-detail-content').innerHTML = '<div class="error">åŠ è½½å¤±è´¥: ' + (res.reason || 'æ•°æ®ä¸ºç©º') + '</div>';
                }
            } catch (e) {
                console.error(e);
                document.getElementById('post-detail-content').innerHTML = '<div class="error">åŠ è½½å¼‚å¸¸</div>';
            }
        }

        function openEditor() {
            switchView('view-editor');
            if (!simplemde) {
                simplemde = new EasyMDE({ 
                    element: document.getElementById("editor-textarea"),
                    toolbar: [
                        "bold", "italic", "heading", "|", 
                        "quote", "unordered-list", "ordered-list", "|",
                        "link", 
                        {
                            name: "image",
                            action: function customImage(editor){
                                document.getElementById('image-upload-input').click();
                            },
                            className: "fa fa-image",
                            title: "ä¸Šä¼ å›¾ç‰‡",
                        },
                        "|",
                        "preview", "side-by-side", "fullscreen", "|", "guide"
                    ],
                    status: ["lines", "words"], // Simplified status bar
                    spellChecker: false,
                });
                
                // Add fullscreen event listener
                simplemde.codemirror.on('refresh', function() {
                    const isFullscreen = simplemde.isFullscreenActive() || simplemde.isSideBySideActive();
                    const btn = document.getElementById('exit-fullscreen-btn');
                    if(btn) btn.style.display = isFullscreen ? 'block' : 'none';
                });
            }
            simplemde.value("");
            document.getElementById('post-title-input').value = "";
        }
        
        async function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Check file type
            const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
            if (!allowedTypes.includes(file.type)) {
                alert('ä»…æ”¯æŒ JPG, PNG, GIF, WebP æ ¼å¼çš„å›¾ç‰‡');
                return;
            }
            
            // Check file size (e.g. 5MB)
            if (file.size > 5 * 1024 * 1024) {
                alert('å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡ 5MB');
                return;
            }
            
            const formData = new FormData();
            formData.append('image', file);
            
            try {
                const response = await fetch('/api/upload_image', {
                    method: 'POST',
                    body: formData
                });
                const res = await response.json();
                
                if (res.status === 0) {
                    const cm = simplemde.codemirror;
                    const doc = cm.getDoc();
                    const cursor = doc.getCursor();
                    const imageMarkdown = `![](${res.url})`;
                    doc.replaceRange(imageMarkdown, cursor);
                } else {
                    alert('ä¸Šä¼ å¤±è´¥: ' + res.reason);
                }
            } catch (e) {
                console.error(e);
                alert('ä¸Šä¼ å‡ºé”™');
            }
            
            // Reset input
            event.target.value = '';
        }

    function exitFullscreen() {
        console.log('[all_questions] exitFullscreen clicked');
        if (!simplemde) {
            console.error('simplemde instance not found');
            return;
        }
        
        // Check both API status and DOM classes for robustness
        const isSideBySide = simplemde.isSideBySideActive() || document.body.classList.contains('side-by-side-active');
        const isFullscreen = simplemde.isFullscreenActive() || document.body.classList.contains('fullscreen-active');
        
        console.log('Status:', { isSideBySide, isFullscreen });

        if (isSideBySide) {
            try {
                simplemde.toggleSideBySide();
                console.log('Toggled side-by-side');
            } catch (e) {
                console.warn('Failed to toggle side-by-side:', e);
            }
        }
        
        if (isFullscreen && !isSideBySide) {
            try {
                simplemde.toggleFullScreen();
                console.log('Toggled fullscreen');
            } catch (e) {
                console.warn('Failed to toggle fullscreen:', e);
            }
        }
    }

        async function savePost() {
            const title = document.getElementById('post-title-input').value;
            const content = simplemde.value();
            
            if(!title || !content) {
                alert('æ ‡é¢˜å’Œå†…å®¹ä¸èƒ½ä¸ºç©º');
                return;
            }
            
            try {
                const response = await fetch('/api/discussion', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({title, content})
                });
                const res = await response.json();
                if(res.status === 0) {
                    alert('å‘å¸ƒæˆåŠŸ');
                    switchView('view-discussion-feed');
                    initDiscussion();
                } else if (res.status === 401) {
                    alert('è¯·å…ˆç™»å½•');
                } else {
                    alert('å‘å¸ƒå¤±è´¥: ' + res.reason);
                }
            } catch(e) {
                console.error(e);
                alert('å‘å¸ƒå¤±è´¥');
            }
        }


        let currentSelectionText = "";

        function showInlineCommentModal() {
            if (!currentSelectionText) return;
            document.getElementById('inline-comment-selected-text').innerText = currentSelectionText;
            
            document.getElementById('inline-comment-modal').style.display = 'flex';
            document.getElementById('inline-comment-tooltip').style.display = 'none';

            // Reset textarea value
            document.getElementById('inline-comment-input').value = "";
        }

        function closeInlineCommentModal() {
            document.getElementById('inline-comment-modal').style.display = 'none';
        }

        async function submitInlineComment() {
            const content = document.getElementById('inline-comment-input').value;
            if (!content) return;

            try {
                const response = await fetch('/api/inline_comment/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        post_id: currentPostId,
                        content: content,
                        selected_text: currentSelectionText
                    })
                });
                const res = await response.json();
                if (res.status === 0) {
                    closeInlineCommentModal();
                    loadInlineComments(); // Refresh highlights
                    alert('è¯„è®ºå‘å¸ƒæˆåŠŸ');
                } else if (res.status === 401) {
                    alert('è¯·å…ˆç™»å½•');
                } else {
                    alert('å‘å¸ƒå¤±è´¥: ' + res.reason);
                }
            } catch (e) {
                console.error(e);
                alert('å‘å¸ƒå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
            }
        }

        let allInlineComments = [];

        async function loadInlineComments() {
        try {
            const response = await fetch('/api/inline_comments/' + currentPostId);
            const res = await response.json();
            if (res.status === 0) {
                allInlineComments = res.data || [];
                highlightInlineComments(allInlineComments);
            }
        } catch (e) {
            console.error('Failed to load comments', e);
        }
    }

    function highlightInlineComments(comments) {
        const contentDiv = document.getElementById('post-markdown-content');
        if (!contentDiv) return;
        
        if (!comments) comments = [];

        // 1. Reset to original clean HTML to prevent nested wrapping/duplication on reload
            if (currentPostRenderedHTML) {
                contentDiv.innerHTML = currentPostRenderedHTML;
            }

            // 2. Sort by length descending to process longer phrases first
            const uniqueTexts = [...new Set(comments.map(c => c.selected_text))]
                .sort((a, b) => b.length - a.length);
            
            let html = contentDiv.innerHTML;
            uniqueTexts.forEach(text => {
                if(!text) return;
                
                // Escape regex special chars in the text
                const escapedText = text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                
                try {
                    // 3. Use Lookbehind Regex: Only match text NOT preceded by an opening tag
                    // This prevents replacing text inside attributes like onclick="..."
                    const regex = new RegExp(`(?<!<[^>]*)${escapedText}`, 'g');
                    
                    html = html.replace(regex, `<span class="inline-comment-target" onclick="openCommentDrawer('${escapeHtml(text.replace(/'/g, "\\'"))}')">${text}</span>`);
                } catch (e) {
                    console.error("Regex error for text:", text, e);
                }
            });
            contentDiv.innerHTML = html;
        }

        function buildCommentTree(comments) {
            const map = {};
            const roots = [];
            // Deep copy to avoid modifying original
            const nodes = comments.map(c => ({...c, children: []}));
            
            nodes.forEach(c => {
                map[c.id] = c;
            });
            
            nodes.forEach(c => {
                if (c.parent_id && c.parent_id !== "0" && map[c.parent_id]) {
                    map[c.parent_id].children.push(c);
                } else {
                    roots.push(c);
                }
            });
            return roots;
        }

        function renderCommentNode(c, depth = 0) {
            const isOwner = (currentUser && currentUser.username === c.username) || (currentUser && currentUser.role === 1);
            const indent = depth * 20;
            
            return `
                <div class="comment-item" style="margin-left: ${indent}px; border-left: ${depth > 0 ? '2px solid rgba(255,255,255,0.1)' : 'none'}; padding-left: ${depth > 0 ? '10px' : '0'}; margin-bottom: 15px;">
                    <div class="comment-meta" style="display:flex; justify-content:space-between; font-size:0.9em; margin-bottom:5px;">
                        <div>
                            <span class="username" style="color:#2cbb5d; font-weight:bold;">${escapeHtml(c.username)}</span>
                            <span class="date" style="color:var(--text-secondary); margin-left:10px;">${c.created_at}</span>
                        </div>
                        <div class="actions">
                            <button onclick="showReplyInput('${c.id}')" style="background:none; border:none; color:var(--text-secondary); cursor:pointer; font-size:0.9em; margin-right:10px;">å›å¤</button>
                            ${isOwner ? `<button onclick="deleteComment('${c.id}')" style="background:none; border:none; color:#ff4d4f; cursor:pointer; font-size:0.9em;">åˆ é™¤</button>` : ''}
                        </div>
                    </div>
                    <div class="comment-content" style="color:var(--text-main); line-height:1.5;">${DOMPurify.sanitize(marked.parse(c.content))}</div>
                    
                    <div id="reply-input-${c.id}" class="reply-input-container" style="display:none; margin-top:10px; padding:10px; background:rgba(0,0,0,0.2); border-radius:4px;">
                        <textarea id="reply-text-${c.id}" placeholder="å›å¤ ${escapeHtml(c.username)}..." style="width:100%; height:60px; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); color:var(--text-main); border-radius:4px; padding:5px; margin-bottom:5px;"></textarea>
                        <div style="text-align:right;">
                             <button onclick="document.getElementById('reply-input-${c.id}').style.display='none'" style="background:none; border:none; color:var(--text-secondary); cursor:pointer; margin-right:10px;">å–æ¶ˆ</button>
                             <button onclick="submitReply('${c.id}', '${escapeHtml(c.selected_text.replace(/'/g, "\\'"))}')" style="padding:4px 12px; background:#2cbb5d; border:none; border-radius:4px; color:white; cursor:pointer;">æäº¤</button>
                        </div>
                    </div>
                    
                    <div class="children">
                        ${c.children.map(child => renderCommentNode(child, depth + 1)).join('')}
                    </div>
                </div>
            `;
        }

        function openCommentDrawer(text) {
            const drawer = document.getElementById('comment-drawer');
            const backdrop = document.getElementById('drawer-backdrop');
            const body = document.getElementById('drawer-body');
            
            // Filter comments for this text
            const comments = allInlineComments.filter(c => c.selected_text === text);
            const commentTree = buildCommentTree(comments);
            
            body.innerHTML = `
                <div class="selected-text-quote">"${escapeHtml(text)}"</div>
                <div class="comments-container">
                    ${commentTree.length > 0 ? commentTree.map(c => renderCommentNode(c)).join('') : '<div style="color:var(--text-secondary); text-align:center; padding:20px;">æš‚æ— è¯„è®º</div>'}
                </div>
            `;
            
            drawer.classList.add('visible');
            backdrop.classList.add('visible');
        }

        function showReplyInput(id) {
            // Hide all other reply inputs? No, let user have multiple open if they want.
            const el = document.getElementById(`reply-input-${id}`);
            if(el) {
                el.style.display = 'block';
                const textarea = document.getElementById(`reply-text-${id}`);
                if(textarea) textarea.focus();
            }
        }

        async function submitReply(parentId, selectedText) {
            const textarea = document.getElementById(`reply-text-${parentId}`);
            const content = textarea.value;
            if(!content) return;
            
            try {
                const response = await fetch('/api/inline_comment/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        post_id: currentPostId,
                        content: content,
                        selected_text: selectedText,
                        parent_id: parentId
                    })
                });
                const res = await response.json();
                if (res.status === 0) {
                    alert('å›å¤æˆåŠŸ');
                    // Reload comments
                    await loadInlineComments();
                    // Re-open drawer for this text to show new comment
                    // We need to find the text again.
                    openCommentDrawer(selectedText); 
                } else if (res.status === 401) {
                    alert('è¯·å…ˆç™»å½•');
                } else {
                    alert('å›å¤å¤±è´¥: ' + res.reason);
                }
            } catch (e) {
                console.error(e);
                alert('å›å¤å¤±è´¥');
            }
        }

        async function deleteComment(id) {
            if(!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡è¯„è®ºå—ï¼Ÿ')) return;
            
            try {
                const response = await fetch('/api/inline_comment/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        comment_id: id
                    })
                });
                const res = await response.json();
                if (res.status === 0) {
                    alert('åˆ é™¤æˆåŠŸ');
                    // We need to refresh. But we need to know the selected text to re-open the drawer.
                    // Let's find the comment in allInlineComments before reloading
                    const comment = allInlineComments.find(c => c.id == id); // loose equality for string/int match
                    const text = comment ? comment.selected_text : null;
                    
                    await loadInlineComments();
                    if(text) openCommentDrawer(text);
                } else {
                    alert('åˆ é™¤å¤±è´¥: ' + res.reason);
                }
            } catch (e) {
                console.error(e);
                alert('åˆ é™¤å¤±è´¥');
            }
        }

        function closeCommentDrawer() {
             document.getElementById('comment-drawer').classList.remove('visible');
             document.getElementById('drawer-backdrop').classList.remove('visible');
        }

        async function loadArticleComments() {
         try {
             const response = await fetch('/api/article_comments/' + currentPostId);
             const res = await response.json();
             if (res.status === 0) {
                 renderArticleComments(res.data || []);
             }
         } catch (e) {
             console.error(e);
         }
    }

    function renderArticleComments(comments) {
        const container = document.getElementById('article-comments-list');
        if (!container) return;
        
        if (!comments) comments = [];

        if (comments.length === 0) {
                container.innerHTML = '<div style="color:var(--text-secondary); padding:10px;">æš‚æ— è¯„è®º</div>';
                return;
            }

            container.innerHTML = comments.map(c => `
                <div class="comment-item" style="border-bottom: 1px solid rgba(255,255,255,0.05); padding: 15px 0;">
                    <div class="comment-meta" style="margin-bottom:5px; font-size:0.9em; color:var(--text-secondary);">
                        <span class="username" style="color:#2cbb5d; margin-right:10px;">${escapeHtml(c.username)}</span>
                        <span class="date">${c.created_at}</span>
                    </div>
                    <div class="comment-content" style="color:var(--text-main);">${escapeHtml(c.content)}</div>
                </div>
            `).join('');
        }

        async function submitArticleComment() {
            const content = document.getElementById('article-comment-input').value;
            if(!content) return;
            
            try {
                const response = await fetch('/api/article_comment/add', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        post_id: currentPostId,
                        content: content
                    })
                });
                const res = await response.json();
                if(res.status === 0) {
                    document.getElementById('article-comment-input').value = "";
                    loadArticleComments();
                } else if(res.status === 401) {
                    alert('è¯·å…ˆç™»å½•');
                } else {
                    alert('å‘å¸ƒå¤±è´¥: ' + res.reason);
                }
            } catch(e) {
                console.error(e);
            }
        }

        function initInlineComments() {
            const content = document.getElementById('post-markdown-content');
            const tooltip = document.getElementById('inline-comment-tooltip');
            const btn = document.getElementById('btn-trigger-comment');
            
            if (btn) {
                btn.onclick = showInlineCommentModal;
            }
            
            content.addEventListener('mouseup', (e) => {
                const selection = window.getSelection();
                const text = selection.toString();
                if (text.length > 0) {
                    currentSelectionText = text;
                    const range = selection.getRangeAt(0);
                    const rect = range.getBoundingClientRect();
                    
                    tooltip.style.display = 'block';
                    tooltip.style.top = (window.scrollY + rect.top - 40) + 'px';
                    tooltip.style.left = (window.scrollX + rect.left + rect.width / 2 - 40) + 'px';
                } else {
                    tooltip.style.display = 'none';
                }
            });
        }
    </script>
</head>
<body>
    <!-- Navbar -->
    <nav class="navbar">
        <div class="navbar-brand">
            <a href="/">
                <span>&lt;/&gt;</span> å†»æ¢¨OJ
            </a>
        </div>
        <div class="navbar-links">
            <a href="/">é¦–é¡µ</a>
            <a href="/all_questions" class="active">é¢˜åº“</a>
            <a href="/contest">ç«èµ›</a>
            <a href="/discussion" id="nav-discussion">è®¨è®º</a>
            <a href="#">æ±‚èŒ</a>
        </div>
        <div class="navbar-auth" id="auth-container">
            <span class="btn-text loading">åŠ è½½ä¸­...</span>
        </div>
    </nav>

    <div class="question-list-container">
        <div id="view-question-list">
            <div class="question-list-header">
                <h1>é¢˜åº“åˆ—è¡¨</h1>
                <p style="color: var(--text-secondary);">æŒ‘é€‰é€‚åˆä½ çš„é¢˜ç›®è¿›è¡ŒæŒ‘æˆ˜</p>
            </div>

            <table class="question-table">
                <thead>
                    <tr>
                        <th style="width: 80px;">ç¼–å·</th>
                        <th>æ ‡é¢˜</th>
                        <th style="width: 100px;">éš¾åº¦</th>
                    </tr>
                </thead>
                <tbody>
                    {{#question_list}}
                    <tr>
                        <td>{{number}}</td>
                        <td><a href="/question/{{number}}" class="question-link">{{title}}</a></td>
                        <td><span class="difficulty-badge difficulty-{{star}}">{{star}}</span></td>
                    </tr>
                    {{/question_list}}
                </tbody>
            </table>
        </div>

        <!-- Discussion Views -->
        <div id="view-discussion-feed" style="display:none;">
            <div class="discussion-header" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
                <h1 style="color:var(--text-main)">è®¨è®ºåŒº</h1>
                <button class="btn-primary" onclick="openEditor()" style="padding:8px 16px; background:#2cbb5d; border:none; border-radius:4px; color:white; cursor:pointer;">+ å‘èµ·è®¨è®º</button>
            </div>
            <div id="discussion-feed-list"></div>
        </div>

        <div id="view-post-detail" style="display:none;">
            <button class="btn-back" onclick="switchView('view-discussion-feed')" style="background:none; border:none; color:var(--text-secondary); cursor:pointer; margin-bottom:10px;">â† è¿”å›è®¨è®ºåŒº</button>
            <div id="post-detail-content" class="post-detail-container" style="background:var(--card-bg); padding:20px; border-radius:8px;"></div>
            
            <!-- Global Article Comments -->
            <div class="article-comments-section" style="margin-top: 30px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 20px;">
                <h3 style="color:var(--text-main); margin-bottom: 15px;">æ–‡ç« è¯„è®º</h3>
                
                <div class="comment-form" style="margin-bottom:20px;">
                    <textarea id="article-comment-input" placeholder="å‘è¡¨ä½ çš„çœ‹æ³•..." style="width:100%; height:80px; padding:10px; background:rgba(0,0,0,0.2); border:1px solid rgba(255,255,255,0.1); color:var(--text-main); border-radius:4px; margin-bottom:10px;"></textarea>
                    <div style="text-align:right;">
                        <button onclick="submitArticleComment()" class="btn-primary" style="padding:6px 16px; background:#2cbb5d; border:none; border-radius:4px; color:white; cursor:pointer;">å‘è¡¨è¯„è®º</button>
                    </div>
                </div>
                
                <div id="article-comments-list"></div>
            </div>

            <div id="inline-comment-tooltip" style="display:none; position:absolute; background:#333; padding:5px; border-radius:4px; z-index:1000; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
                <button id="btn-trigger-comment" style="background:none; border:none; color:white; cursor:pointer;">ğŸ’¬ è¯„è®º</button>
            </div>
        </div>

        <!-- Comment Drawer -->
        <div id="drawer-backdrop" class="comment-drawer-backdrop" onclick="closeCommentDrawer()"></div>
        <div id="comment-drawer" class="comment-drawer">
            <div class="comment-drawer-header">
                <h3 style="color:var(--text-main); margin:0;">æ®µå†…è¯„è®º</h3>
                <button onclick="closeCommentDrawer()" style="background:none; border:none; color:var(--text-secondary); font-size:1.2em; cursor:pointer;">Ã—</button>
            </div>
            <div id="drawer-body" class="comment-drawer-body"></div>
        </div>

        <!-- Inline Comment Modal -->
        <div id="inline-comment-modal" class="modal-backdrop" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:2000; justify-content:center; align-items:center;">
            <div class="modal-content" style="width: 400px; background:var(--card-bg); padding:20px; border-radius:8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
                <div class="modal-header" style="display:flex; justify-content:space-between; margin-bottom:15px;">
                    <h3 style="color:var(--text-main); margin:0;">æ·»åŠ è¯„è®º</h3>
                    <button onclick="closeInlineCommentModal()" style="background:none; border:none; color:var(--text-secondary); font-size:1.2em; cursor:pointer;">Ã—</button>
                </div>
                <div class="modal-body">
                    <div style="margin-bottom: 10px; padding: 10px; background:rgba(255,255,255,0.05); border-radius: 4px; font-size: 0.9em; color: var(--text-secondary);">
                        <div style="margin-bottom: 4px;">é€‰ä¸­å†…å®¹ï¼š</div>
                        <div id="inline-comment-selected-text" style="font-style: italic; color: var(--text-main); max-height: 60px; overflow: hidden; text-overflow: ellipsis;"></div>
                    </div>
                    <textarea id="inline-comment-input" placeholder="å†™ä¸‹ä½ çš„æƒ³æ³•..." style="width: 100%; height: 100px; padding: 10px; background:rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.1); color: var(--text-main); border-radius: 4px; resize: vertical; margin-bottom: 15px;"></textarea>
                </div>
                <div class="modal-footer" style="text-align:right;">
                    <button onclick="closeInlineCommentModal()" style="padding:8px 16px; background:transparent; border:1px solid rgba(255,255,255,0.2); border-radius:4px; color:var(--text-main); cursor:pointer; margin-right:10px;">å–æ¶ˆ</button>
                    <button onclick="submitInlineComment()" style="padding:8px 16px; background:#2cbb5d; border:none; border-radius:4px; color:white; cursor:pointer;">å‘å¸ƒ</button>
                </div>
            </div>
        </div>

        <div id="view-editor" style="display:none;">
             <button class="btn-back" onclick="switchView('view-discussion-feed')" style="background:none; border:none; color:var(--text-secondary); cursor:pointer; margin-bottom:10px;">â† å–æ¶ˆ</button>
             <h2 style="color:var(--text-main); margin-bottom:20px;">å‘å¸ƒæ–‡ç« </h2>
             <input type="text" id="post-title-input" placeholder="è¯·è¾“å…¥æ ‡é¢˜" style="width:100%; padding:10px; margin-bottom:15px; background:var(--card-bg); border:1px solid rgba(255,255,255,0.1); color:var(--text-main); border-radius:4px;">
             <textarea id="editor-textarea"></textarea>
             <!-- Hidden file input for image upload -->
             <input type="file" id="image-upload-input" accept="image/png, image/jpeg, image/gif, image/webp" style="display:none;" onchange="handleImageUpload(event)">
             <!-- Exit Fullscreen Button -->
             <button id="exit-fullscreen-btn" type="button" onclick="exitFullscreen()">é€€å‡ºå…¨å±</button>
             
             <div style="margin-top:20px; text-align:right;">
                <button class="btn-primary" onclick="savePost()" style="padding:8px 24px; background:#2cbb5d; border:none; border-radius:4px; color:white; cursor:pointer;">å‘å¸ƒ</button>
             </div>
        </div>

        <div class="footer">
            &copy; 2026 å†»æ¢¨åœ¨çº¿åˆ¤é¢˜å¹³å°
        </div>
    </div>
</body>
</html>
