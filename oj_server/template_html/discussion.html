<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è®¨è®ºåŒº - å†»æ¢¨OJ</title>
    <link rel="stylesheet" href="/css/index.css">
    <link rel="stylesheet" href="/css/all_questions.css">
    <!-- Markdown Libraries -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/easymde/dist/easymde.min.css">
    <script src="https://cdn.jsdelivr.net/npm/easymde/dist/easymde.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js"></script>
    <!-- PDF.js for PDF import -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <link rel="stylesheet" href="/css/discussion.css">
    <!-- Highlight.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        /* Custom Fullscreen Exit Button */
        #exit-preview-btn {
            position: fixed;
            bottom: 40px;
            right: 40px;
            z-index: 2147483647; /* Max z-index */
            padding: 10px 20px;
            background: rgba(44, 187, 93, 0.9);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
    </style>
    <script>
        // XSSé˜²æŠ¤
        function escapeHtml(text) {
            const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
            return text ? text.replace(/[&<>"']/g, function(m) { return map[m]; }) : '';
        }

        function hideUserMenu() {
            const menu = document.getElementById('user-menu');
            const backdrop = document.getElementById('user-menu-backdrop');
            if (menu) menu.classList.remove('visible');
            if (backdrop) backdrop.classList.remove('visible');
            document.removeEventListener('click', onUserMenuDocumentClick);
        }

        function onUserMenuDocumentClick(event) {
            const profile = document.querySelector('.user-profile');
            const menu = document.getElementById('user-menu');
            if (!profile || !menu) {
                hideUserMenu();
                return;
            }
            if (!profile.contains(event.target) && !menu.contains(event.target)) {
                hideUserMenu();
            }
        }

        function toggleUserMenu(event) {
            event.stopPropagation();
            console.log('[discussion toggleUserMenu] called');
            const menu = document.getElementById('user-menu');
            const backdrop = document.getElementById('user-menu-backdrop');
            if (!menu || !backdrop) {
                console.warn('[discussion toggleUserMenu] menu or backdrop not found');
                return;
            }
            const isVisible = menu.classList.contains('visible');
            console.log('[discussion toggleUserMenu] isVisible =', isVisible);
            if (isVisible) {
                hideUserMenu();
            } else {
                menu.classList.add('visible');
                backdrop.classList.add('visible');
                document.addEventListener('click', onUserMenuDocumentClick);
                console.log('[discussion toggleUserMenu] menu opened');
            }
        }

        async function handleLogout(event) {
            event.stopPropagation();
            try {
                const response = await fetch('/api/logout', {
                    method: 'GET'
                });
                const data = await response.json();
                if (data.status === 0) {
                    window.location.reload();
                } else {
                    alert('ç™»å‡ºå¤±è´¥ï¼š' + (data.reason || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (e) {
                alert('ç™»å‡ºè¯·æ±‚å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
            }
        }

        function updateNavAuth(data) {
            const authContainer = document.getElementById('auth-container');
            if (data.status === 0 && data.username) {
                currentUser = data;
                authContainer.innerHTML = `
                    <div class="user-profile" onclick="toggleUserMenu(event)">
                        <div class="user-avatar">${data.username.charAt(0).toUpperCase()}</div>
                        <span>${escapeHtml(data.username)}</span>
                    </div>
                    <div class="user-menu-backdrop" id="user-menu-backdrop" onclick="hideUserMenu()"></div>
                    <div class="user-menu" id="user-menu">
                        <a href="/profile" class="user-menu-item">ä¸ªäººä¸­å¿ƒ</a>
                        <button type="button" class="user-menu-item" onclick="handleLogout(event)">é€€å‡ºç™»å½•</button>
                    </div>
                `;
            } else {
                authContainer.innerHTML = `<a href="/login" class="btn-text">ç™»å½• / æ³¨å†Œ</a>`;
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            console.log('[discussion] DOMContentLoaded');
            
            // Initialize discussion feed
            initDiscussion();

            const authContainer = document.getElementById('auth-container');
            if (!authContainer) {
                console.error('[discussion] #auth-container not found');
                return;
            }
            authContainer.innerHTML = '<span class="btn-text loading">åŠ è½½ä¸­...</span>';

            fetch('/api/user')
                .then(res => res.json())
                .then(data => {
                    console.log('[discussion] /api/user response', data);
                    updateNavAuth(data);
                })
                .catch(err => {
                    console.error('[discussion] /api/user error', err);
                    updateNavAuth({status: -1});
                });
        });

        // --- View Management ---
        function switchView(viewId) {
            // Hide all views
            ['view-discussion-feed', 'view-post-detail', 'view-editor'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = 'none';
            });
            
            // Show target view
            const target = document.getElementById(viewId);
            if (target) {
                target.style.display = 'block';
            }
        }

        // --- Discussion Module Logic ---
        let simplemde = null;
        let currentUser = null;
        let currentPostRenderedHTML = "";
        
        async function initDiscussion() {
            try {
                const response = await fetch('/api/discussions');
                const res = await response.json();
                if (res.status === 0) {
                    renderFeed(res.data || []);
                } else {
                    console.error('Failed to load discussions');
                }
            } catch (e) {
                console.error(e);
            }
        }

        function renderFeed(posts) {
            const container = document.getElementById('discussion-feed-list');
            if(!container) return;
            
            if (!posts) posts = [];

            if (posts.length === 0) {
                container.innerHTML = '<div style="text-align:center; padding:40px; color:var(--text-secondary);">æš‚æ— è®¨è®ºï¼Œå¿«æ¥å‘å¸ƒç¬¬ä¸€ç¯‡å§ï¼</div>';
                return;
            }
            
            container.innerHTML = posts.map(post => `
                <div class="discussion-card" onclick="openPost(${post.id})">
                    <div class="card-header">
                        <div class="user-info">
                            <span class="username">${escapeHtml(post.author)}</span>
                            <span class="date">Â· ${post.date}</span>
                        </div>
                        ${post.isOfficial ? '<span class="tag-official">å®˜æ–¹</span>' : ''}
                    </div>
                    <h3 class="card-title">${escapeHtml(post.title)}</h3>
                    <p class="card-summary">${escapeHtml(post.summary)}</p>
                    <div class="card-footer">
                        <div class="stats">
                            <span>ğŸ‘ ${post.likes}</span>
                            <span>ğŸ‘ ${post.views}</span>
                            <span>ğŸ’¬ ${post.comments}</span>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        let currentPostId = "";

        async function openPost(id) {
            switchView('view-post-detail');
            currentPostId = id;
            document.getElementById('post-detail-content').innerHTML = '<div class="loading">åŠ è½½ä¸­...</div>';
            
            try {
                const response = await fetch('/api/discussion/' + id);
                const res = await response.json();
                if (res.status === 0 && res.data) {
                    const post = res.data;
                    const renderedHTML = marked.parse(post.content || '');
                    currentPostRenderedHTML = renderedHTML;
                    document.getElementById('post-detail-content').innerHTML = `
                        <h1>${escapeHtml(post.title)}</h1>
                        <div class="post-meta">${escapeHtml(post.author)} Â· ${post.date} Â· ğŸ‘ ${post.views}</div>
                        <div class="markdown-body" id="post-markdown-content">
                            ${renderedHTML} 
                        </div>
                    `;
                    
                    // Trigger syntax highlighting
                    document.querySelectorAll('#post-markdown-content pre code').forEach((el) => {
                        try {
                            hljs.highlightElement(el);
                        } catch(e) {
                            console.error('Highlight error:', e);
                        }
                    });

                    initInlineComments();
                    loadInlineComments();
                    loadArticleComments();
                } else {
                    document.getElementById('post-detail-content').innerHTML = '<div class="error">åŠ è½½å¤±è´¥: ' + (res.reason || 'æ•°æ®ä¸ºç©º') + '</div>';
                }
            } catch (e) {
                console.error(e);
                document.getElementById('post-detail-content').innerHTML = '<div class="error">åŠ è½½å¼‚å¸¸</div>';
            }
        }

        function openEditor() {
            switchView('view-editor');
            if (!simplemde) {
                simplemde = new EasyMDE({ 
                    element: document.getElementById("editor-textarea"),
                    toolbar: [
                        "bold", "italic", "heading", "|", 
                        "quote", "unordered-list", "ordered-list", "|",
                        "link", 
                        {
                            name: "image",
                            action: function customImage(editor){
                                document.getElementById('image-upload-input').click();
                            },
                            className: "fa fa-image",
                            title: "ä¸Šä¼ å›¾ç‰‡",
                        },
                        {
                            name: "import",
                            action: function importFile(editor){
                                document.getElementById('file-import-input').click();
                            },
                            className: "fa fa-upload",
                            title: "å¯¼å…¥æ–‡ä»¶(MD/PDF)",
                        },
                        "|",
                        "preview", "side-by-side", "fullscreen", "|", "guide"
                    ],
                    status: ["lines", "words"], // Simplified status bar
                    spellChecker: false,
                });
                
                // Add fullscreen/preview event listener
                simplemde.codemirror.on('refresh', function() {
                    // Only show button in Side-by-Side (Preview) mode
                    const isPreview = simplemde.isSideBySideActive() || simplemde.isPreviewActive();
                    const btn = document.getElementById('exit-preview-btn');
                    if(btn) {
                        btn.style.display = isPreview ? 'block' : 'none';
                        btn.innerText = "é€€å‡ºé¢„è§ˆ";
                    }
                });

                // Add Paste and Drop Listeners for Image Upload
                simplemde.codemirror.on('paste', function(cm, e) {
                    if (e.clipboardData && e.clipboardData.files && e.clipboardData.files.length > 0) {
                        e.preventDefault();
                        const file = e.clipboardData.files[0];
                        uploadImageFile(file);
                    }
                });

                simplemde.codemirror.on('drop', function(cm, e) {
                    if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                        e.preventDefault();
                        const file = e.dataTransfer.files[0];
                        uploadImageFile(file);
                    }
                });
            }
            simplemde.value("");
            document.getElementById('post-title-input').value = "";
        }
        
        async function uploadImageFile(file) {
            if (!file) return;
            
            // Check file type
            const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
            if (!allowedTypes.includes(file.type)) {
                alert('ä»…æ”¯æŒ JPG, PNG, GIF, WebP æ ¼å¼çš„å›¾ç‰‡');
                return;
            }
            
            // Check file size (e.g. 5MB)
            if (file.size > 5 * 1024 * 1024) {
                alert('å›¾ç‰‡å¤§å°ä¸èƒ½è¶…è¿‡ 5MB');
                return;
            }
            
            const formData = new FormData();
            formData.append('image', file);
            
            // Show uploading status in editor
            const cm = simplemde.codemirror;
            const doc = cm.getDoc();
            const cursor = doc.getCursor();
            const loadingText = "![å›¾ç‰‡ä¸Šä¼ ä¸­...]()";
            doc.replaceRange(loadingText, cursor);
            
            // Calculate replacement range to replace loading text later
            const startPos = { line: cursor.line, ch: cursor.ch };
            const endPos = { line: cursor.line, ch: cursor.ch + loadingText.length };

            try {
                const response = await fetch('/api/upload_image', {
                    method: 'POST',
                    body: formData
                });
                const res = await response.json();
                
                if (res.status === 0) {
                    const imageMarkdown = `![](${res.url})`;
                    doc.replaceRange(imageMarkdown, startPos, endPos);
                } else {
                    alert('ä¸Šä¼ å¤±è´¥: ' + res.reason);
                    doc.replaceRange("", startPos, endPos); // Clear loading text
                }
            } catch (e) {
                console.error(e);
                alert('ä¸Šä¼ å‡ºé”™');
                doc.replaceRange("", startPos, endPos);
            }
        }

        async function handleImageUpload(event) {
            const file = event.target.files[0];
            await uploadImageFile(file);
            event.target.value = '';
        }

        async function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const fileName = file.name.toLowerCase();
            let content = "";

            // Show loading indicator if needed
            const originalText = simplemde.value(); // Keep original text just in case

            try {
                if (fileName.endsWith('.md')) {
                    content = await file.text();
                } else if (fileName.endsWith('.pdf')) {
                    // PDF Text Extraction
                    const arrayBuffer = await file.arrayBuffer();
                    const loadingTask = pdfjsLib.getDocument(arrayBuffer);
                    const pdf = await loadingTask.promise;
                    
                    let fullText = "";
                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        const pageText = textContent.items.map(item => item.str).join(' ');
                        fullText += pageText + "\n\n";
                    }
                    content = fullText;
                } else {
                    alert('ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ï¼Œä»…æ”¯æŒ Markdown (.md) å’Œ PDF (.pdf)');
                    event.target.value = '';
                    return;
                }

                if (simplemde) {
                    const currentContent = simplemde.value();
                    if (currentContent && currentContent.trim().length > 0) {
                        if(confirm('å½“å‰ç¼–è¾‘å™¨å·²æœ‰å†…å®¹ï¼Œæ˜¯å¦è¦†ç›–ï¼Ÿ\nç‚¹å‡»â€œç¡®å®šâ€è¦†ç›–ï¼Œç‚¹å‡»â€œå–æ¶ˆâ€è¿½åŠ åˆ°æœ«å°¾ã€‚')) {
                             simplemde.value(content);
                        } else {
                             simplemde.value(currentContent + "\n\n---\n\n" + content);
                        }
                    } else {
                        simplemde.value(content);
                    }
                }
            } catch (e) {
                console.error('Import failed:', e);
                alert('æ–‡ä»¶å¯¼å…¥å¤±è´¥: ' + e.message);
            }
            
            // Reset input
            event.target.value = '';
        }

    function exitPreview() {
        console.log('[discussion] exitPreview clicked');
        if (!simplemde) {
            console.error('simplemde instance not found');
            return;
        }
        
        // Check both API status and DOM classes for robustness
        const isSideBySide = simplemde.isSideBySideActive() || document.body.classList.contains('side-by-side-active');
        const isPreview = simplemde.isPreviewActive() || document.body.classList.contains('editor-preview-active');
        
        console.log('Status:', { isSideBySide, isPreview });

        if (isSideBySide) {
            try {
                simplemde.toggleSideBySide();
                console.log('Toggled side-by-side');
            } catch (e) {
                console.warn('Failed to toggle side-by-side:', e);
            }
        } else if (isPreview) {
            try {
                simplemde.togglePreview();
                console.log('Toggled preview');
            } catch (e) {
                console.warn('Failed to toggle preview:', e);
            }
        }
    }

        async function savePost() {
            const title = document.getElementById('post-title-input').value;
            const content = simplemde.value();
            
            if(!title || !content) {
                alert('æ ‡é¢˜å’Œå†…å®¹ä¸èƒ½ä¸ºç©º');
                return;
            }
            
            try {
                const response = await fetch('/api/discussion', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({title, content})
                });
                const res = await response.json();
                if(res.status === 0) {
                    alert('å‘å¸ƒæˆåŠŸ');
                    switchView('view-discussion-feed');
                    initDiscussion();
                } else if (res.status === 401) {
                    alert('è¯·å…ˆç™»å½•');
                } else {
                    alert('å‘å¸ƒå¤±è´¥: ' + res.reason);
                }
            } catch(e) {
                console.error(e);
                alert('å‘å¸ƒå¤±è´¥');
            }
        }


        let currentSelectionText = "";

        function showInlineCommentModal() {
            if (!currentSelectionText) return;
            document.getElementById('inline-comment-selected-text').innerText = currentSelectionText;
            
            document.getElementById('inline-comment-modal').style.display = 'flex';
            document.getElementById('inline-comment-tooltip').style.display = 'none';

            // Reset textarea value
            document.getElementById('inline-comment-input').value = "";
        }

        function closeInlineCommentModal() {
            document.getElementById('inline-comment-modal').style.display = 'none';
        }

        async function submitInlineComment() {
            const content = document.getElementById('inline-comment-input').value;
            if (!content) return;

            try {
                const response = await fetch('/api/inline_comment/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        post_id: currentPostId,
                        content: content,
                        selected_text: currentSelectionText
                    })
                });
                const res = await response.json();
                if (res.status === 0) {
                    closeInlineCommentModal();
                    loadInlineComments(); // Refresh highlights
                    alert('è¯„è®ºå‘å¸ƒæˆåŠŸ');
                } else if (res.status === 401) {
                    alert('è¯·å…ˆç™»å½•');
                } else {
                    alert('å‘å¸ƒå¤±è´¥: ' + res.reason);
                }
            } catch (e) {
                console.error(e);
                alert('å‘å¸ƒå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
            }
        }

        let allInlineComments = [];

        async function loadInlineComments() {
        try {
            const response = await fetch('/api/inline_comments/' + currentPostId);
            const res = await response.json();
            if (res.status === 0) {
                allInlineComments = res.data || [];
                highlightInlineComments(allInlineComments);
            }
        } catch (e) {
            console.error('Failed to load comments', e);
        }
    }

    function highlightInlineComments(comments) {
        const contentDiv = document.getElementById('post-markdown-content');
        if (!contentDiv) return;
        
        if (!comments) comments = [];

        // Use the original rendered HTML as base to avoid accumulated DOM changes
        let html = currentPostRenderedHTML || contentDiv.innerHTML;

        // --- PROTECT CODE BLOCKS ---
        // Replace code blocks with placeholders to prevent inline comments from breaking code or highlighting
        const codePlaceholders = [];
        let placeholderIndex = 0;
        
        // Regex to match <pre>...</pre> AND inline <code>...</code>
        // We match <pre> first because it usually contains <code>
        const codeBlockRegex = /(<pre[\s\S]*?<\/pre>)|(<code[^>]*>[\s\S]*?<\/code>)/gi;
        
        html = html.replace(codeBlockRegex, (match) => {
            const placeholder = `<!--CODE_PLACEHOLDER_${placeholderIndex++}-->`;
            codePlaceholders.push(match);
            return placeholder;
        });
        // ---------------------------

        // Sort by length descending to process longer phrases first
        const uniqueTexts = [...new Set(comments.map(c => c.selected_text))]
            .sort((a, b) => b.length - a.length);
        
        uniqueTexts.forEach(text => {
            if(!text) return;
            
            // Escape regex special chars in the text
            const escapedText = text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            
            try {
                // Use Lookbehind Regex: Only match text NOT preceded by an opening tag
                // This prevents replacing text inside attributes like onclick="..."
                const regex = new RegExp(`(?<!<[^>]*)${escapedText}`, 'g');
                
                html = html.replace(regex, `<span class="inline-comment-target" onclick="openCommentDrawer('${escapeHtml(text.replace(/'/g, "\\'"))}')">${text}</span>`);
            } catch (e) {
                console.error("Regex error for text:", text, e);
            }
        });

        // --- RESTORE CODE BLOCKS ---
        html = html.replace(/<!--CODE_PLACEHOLDER_(\d+)-->/g, (match, index) => {
            return codePlaceholders[parseInt(index)] || match;
        });
        // ---------------------------

        contentDiv.innerHTML = html;

        // Trigger syntax highlighting again because innerHTML was reset
        document.querySelectorAll('#post-markdown-content pre code').forEach((el) => {
            try {
                hljs.highlightElement(el);
            } catch(e) {
                console.error('Highlight error:', e);
            }
        });
    }

        function buildCommentTree(comments) {
            const map = {};
            const roots = [];
            // Deep copy to avoid modifying original
            const nodes = comments.map(c => ({...c, children: []}));
            
            nodes.forEach(c => {
                map[c.id] = c;
            });
            
            nodes.forEach(c => {
                if (c.parent_id && c.parent_id !== "0" && map[c.parent_id]) {
                    map[c.parent_id].children.push(c);
                } else {
                    roots.push(c);
                }
            });
            return roots;
        }

        function renderCommentNode(c, depth = 0) {
            const isOwner = (currentUser && currentUser.username === c.username) || (currentUser && currentUser.role === 1);
            const indent = depth * 20;
            
            return `
                <div class="comment-item" style="margin-left: ${indent}px; border-left: ${depth > 0 ? '2px solid rgba(255,255,255,0.1)' : 'none'}; padding-left: ${depth > 0 ? '10px' : '0'}; margin-bottom: 15px;">
                    <div class="comment-meta" style="display:flex; justify-content:space-between; font-size:0.9em; margin-bottom:5px;">
                        <div>
                            <span class="username" style="color:#2cbb5d; font-weight:bold;">${escapeHtml(c.username)}</span>
                            <span class="date" style="color:var(--text-secondary); margin-left:10px;">${c.created_at}</span>
                        </div>
                        <div class="actions">
                            <button onclick="showReplyInput('${c.id}')" style="background:none; border:none; color:var(--text-secondary); cursor:pointer; font-size:0.9em; margin-right:10px;">å›å¤</button>
                            ${isOwner ? `<button onclick="deleteComment('${c.id}')" style="background:none; border:none; color:#ff4d4f; cursor:pointer; font-size:0.9em;">åˆ é™¤</button>` : ''}
                        </div>
                    </div>
                    <div class="comment-content" style="color:var(--text-main); line-height:1.5;">${DOMPurify.sanitize(marked.parse(c.content))}</div>
                    
                    <div id="reply-input-${c.id}" class="reply-input-container" style="display:none; margin-top:10px; padding:10px; background:rgba(0,0,0,0.2); border-radius:4px;">
                        <textarea id="reply-text-${c.id}" placeholder="å›å¤ ${escapeHtml(c.username)}..." style="width:100%; height:60px; background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); color:var(--text-main); border-radius:4px; padding:5px; margin-bottom:5px;"></textarea>
                        <div style="text-align:right;">
                             <button onclick="document.getElementById('reply-input-${c.id}').style.display='none'" style="background:none; border:none; color:var(--text-secondary); cursor:pointer; margin-right:10px;">å–æ¶ˆ</button>
                             <button onclick="submitReply('${c.id}', '${escapeHtml(c.selected_text.replace(/'/g, "\\'"))}')" style="padding:4px 12px; background:#2cbb5d; border:none; border-radius:4px; color:white; cursor:pointer;">æäº¤</button>
                        </div>
                    </div>
                    
                    <div class="children">
                        ${c.children.map(child => renderCommentNode(child, depth + 1)).join('')}
                    </div>
                </div>
            `;
        }

        function openCommentDrawer(text) {
            const drawer = document.getElementById('comment-drawer');
            const backdrop = document.getElementById('drawer-backdrop');
            const body = document.getElementById('drawer-body');
            
            // Filter comments for this text
            const comments = allInlineComments.filter(c => c.selected_text === text);
            const commentTree = buildCommentTree(comments);
            
            body.innerHTML = `
                <div class="selected-text-quote">"${escapeHtml(text)}"</div>
                <div class="comments-container">
                    ${commentTree.length > 0 ? commentTree.map(c => renderCommentNode(c)).join('') : '<div style="color:var(--text-secondary); text-align:center; padding:20px;">æš‚æ— è¯„è®º</div>'}
                </div>
            `;
            
            drawer.classList.add('visible');
            backdrop.classList.add('visible');
        }

        function showReplyInput(id) {
            // Hide all other reply inputs? No, let user have multiple open if they want.
            const el = document.getElementById(`reply-input-${id}`);
            if(el) {
                el.style.display = 'block';
                const textarea = document.getElementById(`reply-text-${id}`);
                if(textarea) textarea.focus();
            }
        }

        async function submitReply(parentId, selectedText) {
            const textarea = document.getElementById(`reply-text-${parentId}`);
            const content = textarea.value;
            if(!content) return;
            
            try {
                const response = await fetch('/api/inline_comment/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        post_id: currentPostId,
                        content: content,
                        selected_text: selectedText,
                        parent_id: parentId
                    })
                });
                const res = await response.json();
                if (res.status === 0) {
                    alert('å›å¤æˆåŠŸ');
                    // Reload comments
                    await loadInlineComments();
                    // Re-open drawer for this text to show new comment
                    // We need to find the text again.
                    openCommentDrawer(selectedText); 
                } else if (res.status === 401) {
                    alert('è¯·å…ˆç™»å½•');
                } else {
                    alert('å›å¤å¤±è´¥: ' + res.reason);
                }
            } catch (e) {
                console.error(e);
                alert('å›å¤å¤±è´¥');
            }
        }

        async function deleteComment(id) {
            if(!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡è¯„è®ºå—ï¼Ÿ')) return;
            
            try {
                const response = await fetch('/api/inline_comment/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        comment_id: id
                    })
                });
                const res = await response.json();
                if (res.status === 0) {
                    alert('åˆ é™¤æˆåŠŸ');
                    // We need to refresh. But we need to know the selected text to re-open the drawer.
                    // Let's find the comment in allInlineComments before reloading
                    const comment = allInlineComments.find(c => c.id == id); // loose equality for string/int match
                    const text = comment ? comment.selected_text : null;
                    
                    await loadInlineComments();
                    if(text) openCommentDrawer(text);
                } else {
                    alert('åˆ é™¤å¤±è´¥: ' + res.reason);
                }
            } catch (e) {
                console.error(e);
                alert('åˆ é™¤å¤±è´¥');
            }
        }

        function closeCommentDrawer() {
             document.getElementById('comment-drawer').classList.remove('visible');
             document.getElementById('drawer-backdrop').classList.remove('visible');
        }

        async function loadArticleComments() {
         try {
             const response = await fetch('/api/article_comments/' + currentPostId);
             const res = await response.json();
             if (res.status === 0) {
                 renderArticleComments(res.data || []);
             }
         } catch (e) {
             console.error(e);
         }
    }

    function renderArticleComments(comments) {
        const container = document.getElementById('article-comments-list');
        if (!container) return;
        
        if (!comments) comments = [];

        if (comments.length === 0) {
                container.innerHTML = '<div style="color:var(--text-secondary); padding:10px;">æš‚æ— è¯„è®º</div>';
                return;
            }

            container.innerHTML = comments.map(c => `
                <div class="comment-item" style="border-bottom: 1px solid rgba(255,255,255,0.05); padding: 15px 0;">
                    <div class="comment-meta" style="margin-bottom:5px; font-size:0.9em; color:var(--text-secondary);">
                        <span class="username" style="color:#2cbb5d; margin-right:10px;">${escapeHtml(c.username)}</span>
                        <span class="date">${c.created_at}</span>
                    </div>
                    <div class="comment-content" style="color:var(--text-main);">${escapeHtml(c.content)}</div>
                </div>
            `).join('');
        }

        async function submitArticleComment() {
            const content = document.getElementById('article-comment-input').value;
            if(!content) return;
            
            try {
                const response = await fetch('/api/article_comment/add', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        post_id: currentPostId,
                        content: content
                    })
                });
                const res = await response.json();
                if(res.status === 0) {
                    document.getElementById('article-comment-input').value = "";
                    loadArticleComments();
                } else if(res.status === 401) {
                    alert('è¯·å…ˆç™»å½•');
                } else {
                    alert('å‘å¸ƒå¤±è´¥: ' + res.reason);
                }
            } catch(e) {
                console.error(e);
            }
        }

        function initInlineComments() {
            const content = document.getElementById('post-markdown-content');
            const tooltip = document.getElementById('inline-comment-tooltip');
            const btn = document.getElementById('btn-trigger-comment');
            
            if (btn) {
                btn.onclick = showInlineCommentModal;
            }
            
            content.addEventListener('mouseup', (e) => {
                const selection = window.getSelection();
                const text = selection.toString();
                if (text.length > 0) {
                    currentSelectionText = text;
                    const range = selection.getRangeAt(0);
                    const rect = range.getBoundingClientRect();
                    
                    tooltip.style.display = 'block';
                    tooltip.style.top = (window.scrollY + rect.top - 40) + 'px';
                    tooltip.style.left = (window.scrollX + rect.left + rect.width / 2 - 40) + 'px';
                } else {
                    tooltip.style.display = 'none';
                }
            });
        }
    </script>
</head>
<body>
    <!-- Navbar -->
    <nav class="navbar">
        <div class="navbar-brand">
            <a href="/">
                <span>&lt;/&gt;</span> å†»æ¢¨OJ
            </a>
        </div>
        <div class="navbar-links">
            <a href="/">é¦–é¡µ</a>
            <a href="/all_questions">é¢˜åº“</a>
            <a href="/contest">ç«èµ›</a>
            <a href="/discussion" class="active">è®¨è®º</a>
            <a href="#">æ±‚èŒ</a>
        </div>
        <div class="navbar-auth" id="auth-container">
            <span class="btn-text loading">åŠ è½½ä¸­...</span>
        </div>
    </nav>

    <div class="question-list-container">
        <!-- Discussion Views -->
        <div id="view-discussion-feed">
            <div class="discussion-header" style="display:flex; justify-content:space-between; align-items:center; margin-bottom:20px;">
                <h1 style="color:var(--text-main)">è®¨è®ºåŒº</h1>
                <button class="btn-primary" onclick="openEditor()" style="padding:8px 16px; background:#2cbb5d; border:none; border-radius:4px; color:white; cursor:pointer;">+ å‘èµ·è®¨è®º</button>
            </div>
            <div id="discussion-feed-list"></div>
        </div>

        <div id="view-post-detail" style="display:none;">
            <button class="btn-back" onclick="switchView('view-discussion-feed')" style="background:none; border:none; color:var(--text-secondary); cursor:pointer; margin-bottom:10px;">â† è¿”å›è®¨è®ºåŒº</button>
            <div id="post-detail-content" class="post-detail-container" style="background:var(--card-bg); padding:20px; border-radius:8px;"></div>
            
            <!-- Global Article Comments -->
            <div class="article-comments-section" style="margin-top: 30px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 20px;">
                <h3 style="color:var(--text-main); margin-bottom: 15px;">æ–‡ç« è¯„è®º</h3>
                
                <div class="comment-form" style="margin-bottom:20px;">
                    <textarea id="article-comment-input" placeholder="å‘è¡¨ä½ çš„çœ‹æ³•..." style="width:100%; height:80px; padding:10px; background:rgba(0,0,0,0.2); border:1px solid rgba(255,255,255,0.1); color:var(--text-main); border-radius:4px; margin-bottom:10px;"></textarea>
                    <div style="text-align:right;">
                        <button onclick="submitArticleComment()" class="btn-primary" style="padding:6px 16px; background:#2cbb5d; border:none; border-radius:4px; color:white; cursor:pointer;">å‘è¡¨è¯„è®º</button>
                    </div>
                </div>
                
                <div id="article-comments-list"></div>
            </div>

            <div id="inline-comment-tooltip" style="display:none; position:absolute; background:#333; padding:5px; border-radius:4px; z-index:1000; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
                <button id="btn-trigger-comment" style="background:none; border:none; color:white; cursor:pointer;">ğŸ’¬ è¯„è®º</button>
            </div>
        </div>

        <!-- Comment Drawer -->
        <div id="drawer-backdrop" class="comment-drawer-backdrop" onclick="closeCommentDrawer()"></div>
        <div id="comment-drawer" class="comment-drawer">
            <div class="comment-drawer-header">
                <h3 style="color:var(--text-main); margin:0;">æ®µå†…è¯„è®º</h3>
                <button onclick="closeCommentDrawer()" style="background:none; border:none; color:var(--text-secondary); font-size:1.2em; cursor:pointer;">Ã—</button>
            </div>
            <div id="drawer-body" class="comment-drawer-body"></div>
        </div>

        <!-- Inline Comment Modal -->
        <div id="inline-comment-modal" class="modal-backdrop" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:2000; justify-content:center; align-items:center;">
            <div class="modal-content" style="width: 400px; background:var(--card-bg); padding:20px; border-radius:8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
                <div class="modal-header" style="display:flex; justify-content:space-between; margin-bottom:15px;">
                    <h3 style="color:var(--text-main); margin:0;">æ·»åŠ è¯„è®º</h3>
                    <button onclick="closeInlineCommentModal()" style="background:none; border:none; color:var(--text-secondary); font-size:1.2em; cursor:pointer;">Ã—</button>
                </div>
                <div class="modal-body">
                    <div style="margin-bottom: 10px; padding: 10px; background:rgba(255,255,255,0.05); border-radius: 4px; font-size: 0.9em; color: var(--text-secondary);">
                        <div style="margin-bottom: 4px;">é€‰ä¸­å†…å®¹ï¼š</div>
                        <div id="inline-comment-selected-text" style="font-style: italic; color: var(--text-main); max-height: 60px; overflow: hidden; text-overflow: ellipsis;"></div>
                    </div>
                    <textarea id="inline-comment-input" placeholder="å†™ä¸‹ä½ çš„æƒ³æ³•..." style="width: 100%; height: 100px; padding: 10px; background:rgba(0,0,0,0.2); border: 1px solid rgba(255,255,255,0.1); color: var(--text-main); border-radius: 4px; resize: vertical; margin-bottom: 15px;"></textarea>
                </div>
                <div class="modal-footer" style="text-align:right;">
                    <button onclick="closeInlineCommentModal()" style="padding:8px 16px; background:transparent; border:1px solid rgba(255,255,255,0.2); border-radius:4px; color:var(--text-main); cursor:pointer; margin-right:10px;">å–æ¶ˆ</button>
                    <button onclick="submitInlineComment()" style="padding:8px 16px; background:#2cbb5d; border:none; border-radius:4px; color:white; cursor:pointer;">å‘å¸ƒ</button>
                </div>
            </div>
        </div>

        <div id="view-editor" style="display:none;">
             <button class="btn-back" onclick="switchView('view-discussion-feed')" style="background:none; border:none; color:var(--text-secondary); cursor:pointer; margin-bottom:10px;">â† å–æ¶ˆ</button>
             <h2 style="color:var(--text-main); margin-bottom:20px;">å‘å¸ƒæ–‡ç« </h2>
             <input type="text" id="post-title-input" placeholder="è¯·è¾“å…¥æ ‡é¢˜" style="width:100%; padding:10px; margin-bottom:15px; background:var(--card-bg); border:1px solid rgba(255,255,255,0.1); color:var(--text-main); border-radius:4px;">
             <textarea id="editor-textarea"></textarea>
             <!-- Hidden file input for image upload -->
             <input type="file" id="image-upload-input" accept="image/png, image/jpeg, image/gif, image/webp" style="display:none;" onchange="handleImageUpload(event)">
             <!-- Hidden file input for file import (md, pdf) -->
             <input type="file" id="file-import-input" accept=".md,.pdf" style="display:none;" onchange="handleFileImport(event)">
             <!-- Exit Preview Button -->
             <button id="exit-preview-btn" type="button" onclick="exitPreview()">é€€å‡ºé¢„è§ˆ</button>
             
             <div class="editor-footer-spacer"></div>
             
             <div class="editor-footer">
                <button class="btn-primary" onclick="savePost()" style="padding:8px 24px; background:#2cbb5d; border:none; border-radius:4px; color:white; cursor:pointer;">å‘å¸ƒ</button>
             </div>
        </div>

        <div class="footer">
            &copy; 2026 å†»æ¢¨åœ¨çº¿åˆ¤é¢˜å¹³å°
        </div>
    </div>
</body>
</html>